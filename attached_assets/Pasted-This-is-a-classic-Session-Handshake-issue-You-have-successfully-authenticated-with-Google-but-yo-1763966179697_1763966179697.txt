This is a classic "Session Handshake" issue. You have successfully authenticated with Google, but your backend isn't "telling" your frontend that the user is now logged in according to *your* system's rules.

Based on your database schema image, your `user` table is set up for email/password (using `password_hash`). To make Google Auth work alongside this, you need to bridge the gap between Google's response and your `user` table.

Here is the step-by-step solution to fix the "Not logged in on Home" issue.

-----

### 1\. Update Your Database Schema

Looking at your schema image, your `user` table expects a `password_hash`. Google users won't have one. You need to modify the table to accommodate them.

**Required Changes:**

1.  **Add a `google_id` column:** To store the unique ID Google sends you.
2.  **Make `password_hash` nullable:** So you can create users who only use Google.

**SQL Command (PostgreSQL example):**

```sql
ALTER TABLE "user" ADD COLUMN google_id VARCHAR(255) UNIQUE;
ALTER TABLE "user" ALTER COLUMN password_hash DROP NOT NULL;
```

-----

### 2\. The Logic Gap (Why it fails)

Currently, your flow likely stops halfway:

1.  User clicks Google Login.
2.  Google verifies them and sends them back to your `callback` route.
3.  **MISSING STEP:** Your server receives the Google user but doesn't create a session *for your specific app*.
4.  Redirect to Home -\> Browser checks for your app's cookie/token -\> Finds none -\> User appears logged out.

### 3\. The Fix: Unified Login Logic

You need to update your **Google Callback Route** (the backend endpoint Google redirects to). It needs to do three things: **Find/Create**, **Link**, and **Issue Session**.

Here is the logic flow you must implement in that route:

#### Step A: Get User Details from Google

Receive the `accessToken` and `profile` (email, google\_id) from Google.

#### Step B: Database Lookup (The "Upsert" Logic)

Check your database for this user.

  * **Case 1: User exists via Google ID.**
      * Great, just log them in.
  * **Case 2: User exists via Email (but no Google ID).**
      * This means they signed up with Email/Password before.
      * **Action:** Update their row to add the `google_id` so they can use both methods in the future.
  * **Case 3: User does not exist.**
      * **Action:** Create a new row in the `user` table. Set `email` and `google_id`. Leave `password_hash` as `NULL`.

#### Step C: The Critical "Session" Step

**This is where your bug is.** Once you have the `user` object from Step B, you must manually trigger the exact same session logic you use for your Custom Auth.

  * **If you use Cookies/Sessions (e.g., `express-session`):**

    ```javascript
    // Inside Google Callback
    req.session.userId = user.id; // CRITICAL: This links the Google user to your app's session
    req.session.save(err => {
        res.redirect('/home');
    });
    ```

  * **If you use JWTs (JSON Web Tokens):**
    You must generate the token *inside the Google callback* and send it to the client (usually via a cookie or a URL parameter).

    ```javascript
    // Inside Google Callback
    const token = generateToken(user.id); 
    // Set as cookie so the browser has it on the Home page
    res.cookie('auth_token', token, { httpOnly: true }); 
    res.redirect('/home');
    ```

-----

### 4\. Summary of the Flow

| User Action | Custom Auth System | Google Auth System (The Fix) |
| :--- | :--- | :--- |
| **1. Credential Check** | Check Password Hash | Check valid Google Token |
| **2. DB Lookup** | Find by Email | Find by `google_id` OR Email |
| **3. Session Creation** | **Set `req.session.userId`** | **Set `req.session.userId` (Currently Missing)** |
| **4. Result** | Logged In | Logged In |

### Next Step

Since you are on Replit, are you using **Node.js (Express)** or **Python (Flask/Django)** for your backend?

If you tell me your language, I can write the exact code snippet for the **Google Callback Route** to handle the database logic and session creation.